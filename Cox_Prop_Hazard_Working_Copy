### R Function (Testing) ### 

## Set workspace --------------------------------------------------------------

# Set working directory 
setwd("/Users/meredithspalmer/Desktop")
rm(list=ls()); gc()

# Required packages 
library(move2)
library(survival)
library(survminer)
library(ggplot2)   
library(dplyr)
library(lubridate)
library(stringr)
library(sf)
library(forcats)

# User-defined inputs ---------------------------------------------------------

## Time period of interest
# Input: Start and end dates over which analysis is to be conducted 
# Default: Leave blank (NA), encompasses data from entire study 
# Notes: This and following code assumes move2 object is in UTC (MoveBank standard)
time_period_start    <- as.POSIXct("2001-01-01", tz= "UTC")  
time_period_end      <- NA

## Fix NA times (3 options): 
# 1a) Replace NA deploy_off_timestamp with time_period_end
reset_na_end <- "YES"

# 1b) Replace NA deploy_off_timestamp with current date 
reset_systime_end <- "NO"

# 1c) Remove tracks with no deploy_on_timestamp and/or deploy_off_timestamp 
NEED TO CODE THIS 


# Survival year 
# Input: Month of year as %M (e.g, "06" for June, "11" for November)
# Default: Leave blank (NA), survival year assumed to start in January  
survival_year_start  <- "06"

# Censor capture-related mortality
# Input: Number of days (integer) to exclude from analysis post-capture 
QUESTION: do we want to 1) exclude records where individuals die in this period OR 2) do 1 and start all capture histories this no. days post-capture? Assuming 2, but check 
# Inclusive of capture date 
# Default: 0 
censor_capture_mortality <- 2 

# Group comparisons
# Input: Variable to compare across
# Options: sex, lifestage, reproCond_pregnant, reproCond_offspring
group_comparsion_individual <- "sex"          

# Additional plots & diagnostics 
# Input: Yes/No 

# Combined plots as well as individual plots 
combined_survival_hazard_plot <- "YES"        


# Load data -------------------------------------------------------------------

movebank_store_credentials("username", "password", force = T)

## test data sets 

# Mountain caribou in British Columbia: 216040785
mountain_caribou <- movebank_download_study(study_id = 216040785, 'license-md5'='65f5187abc85645e0101229c87a6d93f') 

# Ya Ha Tinda elk project, Banff National Park: 72264071
yahatinda_elk <- movebank_download_study(study_id = 72264071)

# Ya Ha Tinda elk project, Banff National Park, 2001-2024 (females): 897981076
yahatinda_elk_f <- movebank_download_study(study_id = 897981076, 'license-md5'='e0919bb4de3bfa550f80ca513572d5e3')

# Elk in southwestern Alberta: 933711994
swalberta_elk <- movebank_download_study(study_id = 933711994)

# ABoVE: Boutin Alberta Moose: 302664172
alberta_moose <- movebank_download_study(study_id = 302664172)

# Peters Hebblewhite Alberta-BC Moose: 178994931
albertaBC_moose <- movebank_download_study(study_id = 178994931)


## Review ---------------------------------------------------------------------

## Not to be included in final app; for debugging purposes

# Main data 
data_main <- as.data.frame(data)
head(data_main)

# Track data 
data_tracks_full <- as.data.frame(mt_track_data(data))
head(data_tracks_full)
sort(names(data_tracks_full))
desired_cols <- c("deployment_id", "individual_id", 
                  "tag_id", "attachment_type", 
                  "deploy_on_timestamp", "deploy_off_timestamp", 
                  "sex", "animal_life_stage", "animal_reproductive_condition",
                  "deployment_end_comments", "deployment_end_type",
                  "death_comments", "mortality_location",
                  "timestamp_first_deployed_location",
                  "timestamp_last_deployed_location")
data_tracks <- data_tracks_full |> dplyr::select(any_of(desired_cols))
# Notes: keep checking different animals; should be mortality status, mortality type, birth date information 

# Dates 
min(data_tracks$deploy_on_timestamp, na.rm=T)
min(data_tracks$timestamp_first_deployed_location)
max(data_tracks$deploy_off_timestamp, na.rm=T)
max(data_tracks$timestamp_last_deployed_location)
# -> use deploy_on_timestamp instead of timestamp_first_deployed_location 
# -> use deploy_off_timestamp instead of timestamp_last_deployed location 

# Individual IDs
n_total            <- nrow(data_tracks)
n_distinct_deploy  <- n_distinct(data_tracks$deployment_id)
n_distinct_individ <- n_distinct(data_tracks$individual_id)
cat("Total rows:", n_total, "\n")
cat("Unique deployment_ids:", n_distinct_deploy, "\n")
cat("All unique deployment ids?", n_distinct_deploy == n_total, "\n")
cat("Unique individual_ids:", n_distinct_individ, "\n")
cat("All unique individual ids?", n_distinct_individ == n_total, "\n")


## Clean data -----------------------------------------------------------------

data <- mountain_caribou

## Basic cleaning --- 

# Exclude empty locations: 
data <- dplyr::filter(data, !sf::st_is_empty(data)) 
# Exclude marked outliers: 
data <- mt_filter_unique(data)
# Exclude data marked "test": 
data <- data %>% filter_track_data(is_test == FALSE)


## Aggregate across multiple deployments where present --- 

# Extract event-level data 
events <- data |>
  as_tibble() |>
  dplyr::select(deployment_id, timestamp)  

# Extract relevant track-level attributes
tracks <- mt_track_data(data) |>
  mutate(mortality_location_filled = if_else(
    is.na(mortality_location) | st_is_empty(mortality_location),
    0L, 1L)) |> 
  dplyr::select(any_of(c(
    "deployment_id",
    "individual_id",
    "sex",
    "animal_life_stage",
    "animal_reproductive_condition",
    "attachment_type",
    "study_site",
    "deploy_on_timestamp",
    "deploy_off_timestamp",
    "deployment_end_type",
    "deployment_end_comments",
    "death_comments",
    "mortality_location_filled", 
    "mortality_date",
    "mortality_type", 
    "timestamp_first_deployed_location",
    "timestamp_last_deployed_location")))

# Join track attributes to every event row
events_with_ind <- events |>
  left_join(tracks, by = "deployment_id") |>
  relocate(individual_id,deployment_id, timestamp,
           .before = everything())

# Summarize timestamps and location count per individual
summary_table <- events_with_ind |>
  group_by(individual_id) |>
  summarise(
    first_timestamp = min(as.Date(timestamp), na.rm = TRUE),
    last_timestamp  = max(as.Date(timestamp), na.rm = TRUE),
    n_locations     = n(),
    n_deployments   = n_distinct(deployment_id),
    
    # Timestamp columns: min / max if present
    timestamp_first_deployed_location = if ("timestamp_first_deployed_location" %in% names(events_with_ind))
      min(timestamp_first_deployed_location, na.rm = TRUE) else NA,
    
    timestamp_last_deployed_location = if ("timestamp_last_deployed_location" %in% names(events_with_ind))
      max(timestamp_last_deployed_location, na.rm = TRUE) else NA,
    
    deploy_on_timestamp = if ("deploy_on_timestamp" %in% names(events_with_ind)) {
      if (all(is.na(deploy_on_timestamp))) as.POSIXct(NA) else min(deploy_on_timestamp, na.rm = TRUE)
    } else as.POSIXct(NA),
    
    deploy_off_timestamp = if ("deploy_off_timestamp" %in% names(events_with_ind)) {
      if (all(is.na(deploy_off_timestamp))) as.POSIXct(NA) else max(deploy_off_timestamp, na.rm = TRUE)
    } else as.POSIXct(NA),
    
    # Mortality column: 1/0 if filled if present 
    mortality_location_filled = if ("mortality_location_filled" %in% names(events_with_ind))
      as.integer(any(mortality_location_filled >= 1, na.rm = TRUE)) else NA_integer_,
    
    # Categorical columns: collapsed unique if present
    sex = if ("sex" %in% names(events_with_ind))
      str_c(unique(sex[!is.na(sex)]), collapse = " | ") else NA_character_,
    
    death_comments = if ("death_comments" %in% names(events_with_ind))
      str_c(unique(death_comments[!is.na(death_comments)]), collapse = " | ") else NA_character_,
    
    deployment_end_comments = if ("deployment_end_comments" %in% names(events_with_ind))
      str_c(unique(deployment_end_comments[!is.na(deployment_end_comments)]), collapse = " | ") else NA_character_,
    
    deployment_end_type = if ("deployment_end_type" %in% names(events_with_ind))
      str_c(unique(deployment_end_type[!is.na(deployment_end_type)]), collapse = " | ") else NA_character_,
    
    animal_life_stage = if ("animal_life_stage" %in% names(events_with_ind))
      str_c(unique(animal_life_stage[!is.na(animal_life_stage)]), collapse = " | ") else NA_character_,
    
    animal_reproductive_condition = if ("animal_reproductive_condition" %in% names(events_with_ind))
      str_c(unique(animal_reproductive_condition[!is.na(animal_reproductive_condition)]), collapse = " | ") else NA_character_,
    
    attachment_type = if ("attachment_type" %in% names(events_with_ind))
      str_c(unique(attachment_type[!is.na(attachment_type)]), collapse = " | ") else NA_character_,
    
    .groups = "drop"
  ) |>
  mutate(
    
    # Clean empty strings (fill NA) for columns that exist
    across(
      any_of(c(
        "death_comments",
        "deployment_end_comments",
        "deployment_end_type",
        "animal_life_stage",
        "animal_reproductive_condition"
      )),
      ~ if_else(. == "", NA_character_, .)
    ),
    
    # Convert deploy timestamps 
    across(
      any_of(c("deploy_on_timestamp", "deploy_off_timestamp")),
      as.Date
    )
  )


## Clean dates --- 

## Replace "deploy_on_timestamp" with "first_timestamp" if NA 
summary_table <- summary_table %>% 
  mutate(missing_timestamp_start = is.na(deploy_on_timestamp))
n_missing <- sum(is.na(summary_table$deploy_on_timestamp), na.rm = TRUE)

# (diagnostic - remove from final code)
bad_tracks <- summary_table %>%
  filter(missing_timestamp_start) %>%
  dplyr::select(individual_id,
         first_timestamp, 
         last_timestamp,
         deploy_on_timestamp,
         deploy_off_timestamp,
         missing_timestamp_start)
nrow(bad_tracks)
print(bad_tracks)

summary_table <- summary_table %>%
  mutate(deploy_on_timestamp = if_else(
    is.na(deploy_on_timestamp),
    as.Date(first_timestamp),
    deploy_on_timestamp)) %>% 
  dplyr::select(-missing_timestamp_start)

# Warning for data update 
if (n_missing > 0) {
  warning(
    sprintf("Warning: Replaced %d missing deploy_on_timestamp value%s with first_timestamp.", n_missing,
            if (n_missing == 1) "" else "s"), call. = FALSE, immediate. = TRUE)
}


## Replace "deploy_off_timestamp" with "mortality_date" 
WHEN HAVE AN EXAMPLE OF THIS, CODE 


## USER-DEFINED: Replace NA "deploy_off_timestamp" with "last_timestamp" 
# Input: Yes/No 
reset_na_end <- "YES"

if(reset_na_end == "YES"){

    summary_table <- summary_table %>%
      mutate(missing_timestamp_end = is.na(deploy_off_timestamp))
    n_missing <- sum(is.na(summary_table$deploy_off_timestamp), na.rm = TRUE)
    
    # (diagnostic - remove from final code)
    bad_tracks <- summary_table %>%
      filter(missing_timestamp_end) %>%
      dplyr::select(individual_id,
                    first_timestamp, 
                    last_timestamp,
                    deploy_on_timestamp,
                    deploy_off_timestamp,
                    missing_timestamp_end)
    nrow(bad_tracks)
    print(bad_tracks)
  
    summary_table <- summary_table %>%
      mutate(deploy_off_timestamp = if_else(
        is.na(deploy_off_timestamp),
        as.Date(last_timestamp),
        deploy_off_timestamp)) %>% 
      dplyr::select(-missing_timestamp_end)
    
      # Warning for data update 
      if (n_missing > 0) {
        warning(
          sprintf("Warning: Replaced %d missing deploy_off_timestamp value%s with last_timestamp.", n_missing,
                  if (n_missing == 1) "" else "s"), call. = FALSE, immediate. = TRUE)
      }
}


## USER-DEFINED: Replace NA deploy_off_timestamp with current date 
# Input: Yes/No
reset_systime_end <- "NO" 

if(reset_systime_end == "YES"){
  
  summary_table <- summary_table %>%
    mutate(missing_timestamp_end = is.na(deploy_off_timestamp))
  n_missing <- sum(is.na(summary_table$deploy_off_timestamp), na.rm = TRUE)
  
  # (diagnostic - remove from final code)
  bad_tracks <- summary_table %>%
    filter(missing_timestamp_end) %>%
    dplyr::select(individual_id,
                  first_timestamp, 
                  last_timestamp,
                  deploy_on_timestamp,
                  deploy_off_timestamp,
                  missing_timestamp_end)
  nrow(bad_tracks)
  print(bad_tracks)
  
  summary_table <- summary_table %>%
    mutate(deploy_off_timestamp = if_else(
      is.na(deploy_off_timestamp),
      Sys.Date(), 
      deploy_off_timestamp))%>% 
    dplyr::select(-missing_timestamp_end)
  
  if (n_missing > 0) {
    warning(
      sprintf("Warning: Replaced %d missing deploy_off_timestamp value%s with current date.", n_missing,
              if (n_missing == 1) "" else "s"), call. = FALSE, immediate. = TRUE)
  }
}


## Remove data for individuals where "deploy_off_timestamp" occurs before "deploy_on_timestamp" 
n_original <- nrow(summary_table) 
summary_table <- summary_table %>%
  filter(deploy_off_timestamp >= deploy_on_timestamp)


## Warning for data loss 
n_removed <- n_original - nrow(summary_table)  
if (n_removed > 0) {
  warning(sprintf("Warning: Removed %d individual%s where deploy_off_timestamp < deploy_on_timestamp.",
                  n_removed, if (n_removed == 1) "" else "s"),
    call. = FALSE, immediate. = TRUE)
}


## Crop data to user-defined window ---

## USER-DEFINED: Removed censored data (mortalities within set period of capture)
n_before <- nrow(summary_table)

summary_table <- summary_table %>%
  
  # Save raw data 
  mutate(raw_deploy_on_timestamp = deploy_on_timestamp) %>%
  
  # Calculate end of censoring window
  mutate(censor_cutoff = deploy_on_timestamp + lubridate::days(censor_capture_mortality)) %>%
  
  # Remove records where end date is within this window 
  mutate(remove_due_to_early_end = !is.na(deploy_off_timestamp) & deploy_off_timestamp <= censor_cutoff) %>%
  filter(!remove_due_to_early_end) %>%
  
  # Shift deploy_on forward to after censor period for kept records 
  mutate(deploy_on_timestamp = censor_cutoff) %>%
  
  # Clean 
  select(-censor_cutoff, -remove_due_to_early_end)

n_after  <- nrow(summary_table)
n_removed <- n_before - n_after

if (n_removed > 0) {
  warning(
    paste0("Warning: Removed ", n_removed, " individual(s) because deploy_off_timestamp occurred within ",
           censor_capture_mortality, " day(s) after deploy_on_timestamp"),
    call. = FALSE, immediate. = TRUE)
  } 
  

## USER DEFINED: Crop to study period (update based on user-defined inputs): 

# Define window 
effective_start <- if (is.na(time_period_start)) {
  min(summary_table$deploy_on_timestamp, na.rm = TRUE)
} else {
  time_period_start
}

effective_end <- if (is.na(time_period_end)) {
  max(summary_table$deploy_off_timestamp, na.rm = TRUE)
} else {
  time_period_end
}

# Crop to window 
n_original <- nrow(summary_table) 
summary_table <- summary_table %>%
  
  # Retain raw data 
  mutate(raw_deploy_off_timestamp = deploy_off_timestamp) %>%    # "on" already saved 
  
  # Determine if the deployment overlaps study window 
  mutate(overlaps_study = deploy_on_timestamp <= effective_end & 
           deploy_off_timestamp  >= effective_start) %>%
  filter(overlaps_study | is.na(overlaps_study)) %>%    
  
  # Crop to window 
  mutate(first_timestamp = pmax(deploy_on_timestamp, effective_start, na.rm = TRUE),
         last_timestamp  = pmin(deploy_off_timestamp, effective_end,   na.rm = TRUE)) %>%
  
  # Clean 
  select(-overlaps_study) 

# Warning for data loss 
n_removed <- n_original - nrow(summary_table)
if (n_removed > 0) {
  warning(sprintf("Warning: %d record%s did not overlap the user-defined study window and were removed.",
                  n_removed, if (n_removed == 1) "" else "s"),
          call. = FALSE, immediate. = TRUE)
}

# (diagnostic - remove from final code)
summary_table %>%
  filter(raw_deploy_on_timestamp != raw_deploy_on_timestamp | raw_deploy_off_timestamp  != last_timestamp) %>%
  dplyr::select(individual_id,
                raw_deploy_on_timestamp, first_timestamp,
                raw_deploy_off_timestamp, last_timestamp) %>%
  slice_head(n = 10) %>%
  print()


## Calculate entry time and exit time ---
# (for staggered entry; instead of duration days)
origin_date <- if_else(is.na(time_period_start),
                       min(summary_table$deploy_on_timestamp, na.rm = TRUE),
                       time_period_start)

summary_table <- summary_table %>%
  mutate(origin_date = origin_date, 
         entry_time_days  = as.numeric(difftime(deploy_on_timestamp, origin_date, units = "days")),
         exit_time_days   = as.numeric(difftime(deploy_off_timestamp, origin_date, units = "days")))


## (diagnostic - remove from final code) Quick clean: 
summary_table <- summary_table %>%
  dplyr::select(-c(timestamp_first_deployed_location, timestamp_last_deployed_location,
                   origin_date)) %>%
  relocate(individual_id, deploy_on_timestamp, deploy_off_timestamp, first_timestamp,
           last_timestamp, raw_deploy_on_timestamp, raw_deploy_off_timestamp, 
           .before = n_locations) %>%
  relocate(entry_time_days, exit_time_days, .before = n_locations)


## Survival event indicator  -- 
# Here, event = 1 if end_type indicates observed death, 0 if censore

## (diagnostic - remove from final code) death variables:
names(summary_table)
unique(summary_table$mortality_event) #NEED AN EXAMPLE OF THIS; THEN ADD TO CODE 
unique(summary_table$mortality_type) #NEED AN EXAMPLE OF THIS; THEN ADD TO CODE 
# - note: this should be hardcoded: 
# -> if mortality_type is %in%  c("bycatch", "capture", "electrocution", "harvest", "disease", "natural-death", "other", "parasites", "poison", "predation", "starvation", "unknown", "vehicle-collision")
unique(summary_table$mortality_date) #NEED AN EXAMPLE OF THIS; THEN ADD TO CODE 
unique(data_tracks$deployment_end_comments) #IF ANYTHING USEFUL POPS, ADD TO CODE 
unique(summary_table$death_comments)
unique(summary_table$mortality_location_filled)
unique(summary_table$deployment_end_type)
levels(summary_table$deployment_end_type)
# -> look at other variables jasmine has flagged 


summary_table <- summary_table %>%
  
  # Initialize mortality event 
  mutate(mortality_event = NA_real_) %>%
  
  # Identify survivors (individuals who last beyond study)
  mutate(
    survived_beyond_study = !is.na(raw_deploy_off_timestamp) &
      raw_deploy_off_timestamp > as.Date(effective_end),
    
    mortality_event = if_else(survived_beyond_study, 0L, mortality_event),
    
    # Update columns to remove ambiguity (e.g., if animal dies after study window)
    death_comments = if ("death_comments" %in% names(.)) {
      if_else(survived_beyond_study, "survived beyond study", death_comments)
    } else death_comments,
    
    deployment_end_comments = if ("deployment_end_comments" %in% names(.)) {
      if_else(survived_beyond_study, "survived beyond study", deployment_end_comments)
    } else deployment_end_comments,
    
    deployment_end_type = if ("deployment_end_type" %in% names(.)) {
      if_else(survived_beyond_study, "survived beyond study", deployment_end_type)
    } else deployment_end_type,
    
    mortality_location_filled = if ("mortality_location_filled" %in% names(.)) {
      if_else(survived_beyond_study, 0L, mortality_location_filled)
    } else mortality_location_filled
  ) %>%
  
  # Search for mortality indicators 
  # A. death_comments keywords
  mutate(
    mortality_event = case_when(
      "death_comments" %in% names(.) &
        str_detect(tolower(death_comments),
           "dead|death|cod|predation|predator|vehicle|collision|killed|poach|shot|hunt|harvest") ~ 1L,
      mortality_event == 1L ~ 1L,
      TRUE ~ mortality_event
    )
  ) %>%
  
  # B. mortality_location_filled
  mutate(
    mortality_event = case_when(
      "mortality_location_filled" %in% names(.) &
        mortality_location_filled >= 1 ~ 1L,
      
      mortality_event == 1L ~ 1L,
      TRUE ~ mortality_event
    )
  ) %>%
  
  # C. deployment_end_type  
  mutate(
    mortality_event = case_when(
      mortality_event == 1L ~ 1L,
      
      # Mortality indication
      "deployment_end_type" %in% names(.) &
        str_detect(tolower(deployment_end_type), "\\bdead\\b|\\bdeath\\b") ~ 1L,
      
      # Censoring indication
      "deployment_end_type" %in% names(.) &
        tolower(deployment_end_type) %in% c("removal", "other", "unknown", "survived beyond study") ~ 0L,
      
      # Missing column OR NA value → censored 
      (!"deployment_end_type" %in% names(.) | is.na(deployment_end_type)) &
        is.na(mortality_event) ~ 0L,
      
      TRUE ~ mortality_event
    )
  ) %>%
  
  # Final censoring: remaining NA → 0 
  mutate(
    mortality_event = if_else(
      is.na(mortality_event) & !is.na(deploy_off_timestamp),
      0L,
      mortality_event
    )
  ) %>%
  
  # Clean up & relocate
  select(-survived_beyond_study) %>%
  relocate(mortality_event, .after = deployment_end_type)


## Flag sample size issues 

# No deaths 
n_mort_events <- sum(summary_table$mortality_event == 1, na.rm = TRUE)
if (n_mort_events == 0) {
  warning("Cannot run survival analysis: no mortality events detected.",
    call. = FALSE, immediate. = TRUE)
}

# Small proportion of deaths 
# Note: number of events more important than number of individuals for statistical power 
if (n_mort_events <= 10) {
  warning(sprintf("Few (%d) deaths detected. Model may have low statistical power, potentially resulting in unreliable estimates and poor predictive power.", n_mort_events),
          call. = FALSE, immediate. = TRUE)
}


## USER-DEFINED: Attributes --- 
# User can pick ONE ATTRIBUTE by which to segregate their data 

## Sex: m, f, u 
# (diagnostic - remove from final code) 
unique(summary_table$sex); table(summary_table$sex)
# -> if user selections this option, remove NA rows 
QUESTION: can you do three groups or need to remove u as well? 
  
if(group_comparison_individual == "sex"){
  n_original <- nrow(summary_table)
  summary_table <- summary_table[!is.na(summary_table$sex),] 
  n_lost <- n_original - nrow(summary_table)
  if (n_lost > 0) {
    warning(sprintf("%d individuals with NA sex removed from study.", n_lost), 
            call. = FALSE, immediate. = TRUE)
    }
}
# need to check this works on real data 


## Life stage: can be more >2 options 
# (diagnostic - remove from final code) 
unique(summary_table$animal_life_stage); table(summary_table$animal_life_stage)
# -> IF USER SELECTS THIS ATTRIBUTE: clean data, remove NA rows
if(group_comparison_individual == "lifestage"){
  n_original <- nrow(summary_table)
  summary_table <- summary_table %>%
    filter(!is.na(animal_life_stage)) %>%
    mutate(
      animal_life_stage = str_trim(animal_life_stage),
      animal_life_stage = str_replace_all(animal_life_stage, "\\s+", ""),
      animal_life_stage = str_extract(animal_life_stage, "^[^|]+"),
      animal_life_stage = str_replace(animal_life_stage, "–", "-") 
    )
  n_life_stages <- length(unique(summary_table$animal_life_stage))
  warning(sprintf("%d life-stages detected.", n_life_stages), call. = FALSE, immediate. = TRUE)
  n_lost <- n_original - nrow(summary_table)
  if (n_lost > 0) {
    warning(sprintf("%d individuals with NA life stage removed from study.", n_lost_ind), 
            call. = FALSE, immediate. = TRUE)
  }
# need to check this works on real data 
  
  
## Attachment type: 15 options
# (diagnostic - remove from final code) 
unique(summary_table$attachment_type); table(summary_table$attachment_type)
# -> IS USER SELECTIONS THIS OPTION: remove NAs, take first attachment type if muliple 

CODE THIS when have good example 
  
  
## Reproductive condition: can be > 2 options

COMBINE the following; otherwise too many options to anticipiate

# (diagnostic - remove from final code) 
unique(summary_table$animal_reproductive_condition); table(summary_table$animal_reproductive_condition)

# -> IF USER SELECTS THIS ATTRIBUTE, clean data, remove NA rows
DO THIS ON REAL DATA 
if(group_comparison_individual = "reproCond_pregnant"){
  # Remove males & unknowns 
  data <- filter_track_data(data, !is.na(sex) & sex != "m") 
  
  # Divide females into pregnant at capture vs. not 
  data <- data |>
    mutate_track_data(
      animal_reproductive_condition = if_else(
        is.na(animal_reproductive_condition) | animal_reproductive_condition == "",
        "not pregnant",
        animal_reproductive_condition
      )
    )
  LOG: what life stages are found 
  # NOTE: THERE MAY BE DIFFERENT REPRODUCTIVE CONDITIONS LISTED! TEST ON DIF SPECIES 
  
  # Redo sample size 
  n.ind <- length(unique(mt_track_data(data)$individual_id))
  LOG WARNING: sample size is now smaller; n.ind == XXX 
}

# -> IF USER SELECTS THIS ATTRIBUTE, clean data, remove NA rows
if(group_comparison_individual = "reproCond_offspring"){
  
  # Remove males & unknowns 
  n_original <- nrow(summary_table)
  summary_table <- summary_table[!(is.na(summary_table$sex) | summary_table$sex == "m"),]
    filter_track_data(data, !is.na(sex) & sex != "m") 
  n_lost <- n_original - nrow(summary_table)
  if (n_lost > 0) {
    warning(sprintf("%d individuals with NA sex and/or males removed from study.", n_lost_ind), 
            call. = FALSE, immediate. = TRUE)
  }
  
  # Divide females into with calf and without/unknown ... or keep original designations (but may conflate with prgegnancy...)
  unique(summary_table$animal_reproductive_condition)
    # moose: "with calf: N"   "with calf: Unk" "with calf: Y"  
  data <- data |>
    mutate_track_data(
      animal_reproductive_condition = if_else(
        is.na(animal_reproductive_condition) | animal_reproductive_condition == "",
        "not pregnant",
        animal_reproductive_condition
      )
    )
  LOG: what life stages are found 
}


## Basic summaries ------------------------------------------------------------

## Plot length of each individual's tracking: 
# Create a mapping from deployment_id → individual_id (one-to-one)
deployment_to_ind <- mt_track_data(data) |>
  select(deployment_id, individual_id) |>
  distinct()

# Now add individual_id to every location row via join
data_with_ind <- data |>
  left_join(deployment_to_ind, by = "deployment_id")

# Summarise per individual using the actual timestamps
track_times <- data_with_ind |>
  group_by(individual_id) |>
  summarise(
    start    = min(timestamp, na.rm = TRUE),    
    end      = max(timestamp, na.rm = TRUE),
    n_locs   = n(),
    n_deploy = n_distinct(deployment_id),
    .groups  = "drop"
  ) |>
  left_join(
    mt_track_data(data) |>
      distinct(individual_id, .keep_all = TRUE),  # 
    by = "individual_id"
  ) |>
  mutate(
    duration_days = round(as.numeric(difftime(end, start, units = "days")), 1),
    track_label = fct_reorder(as.character(individual_id), start)
  ) |>
  arrange(start)

# Plot 
(tracking_history <- ggplot(track_times) +
  geom_segment(
    aes(x = start, xend = end, y = track_label, yend = track_label),
    linewidth = 3, color = "steelblue"
  ) +
  geom_point(aes(x = start, y = track_label), color = "darkgreen", size = 3.5) +
  geom_point(aes(x = end,   y = track_label), color = "firebrick",  size = 3.5) +
  labs(
    title    = "Tracking History per Individual",
    subtitle = sprintf("%d unique individuals • %d total deployments • %d locations",
                       nrow(track_times),
                       sum(track_times$n_deploy, na.rm = TRUE),
                       sum(track_times$n_locs, na.rm = TRUE)),
    x        = "Time",
    y        = "Individual ID"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.y = element_text(size = 8),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(
      angle = 45,
      hjust = 1,         
      vjust = 1          
    )
  ) +
  scale_x_datetime(
    date_breaks = "1 year",
    date_labels = "%Y"
  ))

ggsave(filename = "tracking_history.png", 
       plot = tracking_history,           
       width = 10, height = 6, units = "in",
       dpi = 300, 
       bg = "white")


## Plot length of each individual's tracking for final (cropped) data: 

# Prepare the data for plotting
track_times <- summary_table %>%
  mutate(
    # Ensure timestamps are Date/POSIXct (already are in your data)
    start = first_timestamp,
    end   = last_timestamp,
    
    # Duration in days (for optional use)
    duration_days = round(as.numeric(difftime(end, start, units = "days")), 1),
    
    # Ordered factor for y-axis (chronological by start time)
    track_label = fct_reorder(as.character(individual_id), start)
  ) %>%
  arrange(start)

# Create the plot
(tracking_history_subset <- ggplot(track_times) +
  geom_segment(
    aes(x = start, xend = end, y = track_label, yend = track_label),
    linewidth = 3, color = "steelblue"
  ) +
  
  geom_point(
    aes(x = start, y = track_label),
    color = "darkgreen", size = 3.5
  ) +
  
  geom_point(
    aes(x = end, y = track_label),
    color = "firebrick", size = 3.5
  ) +
  
  labs(
     title    = "Tracking History per Individual (Data Subset)",
     subtitle = sprintf("%d unique individuals • %d total deployments • %d locations",
                         nrow(track_times),
                         sum(track_times$n_deploy, na.rm = TRUE),
                         sum(track_times$n_locations, na.rm = TRUE)),    
    x = "Time",
    y = "Individual ID"
  ) +
  
  theme_minimal(base_size = 12) +
  theme(
    axis.text.y = element_text(size = 8),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    plot.subtitle = element_text(size = 10, color = "grey50"), 
    axis.text.x = element_text(
      angle = 45,
      hjust = 1,         
      vjust = 1 )
  ) +
  
  scale_x_datetime(
    date_breaks = "1 year",
    date_labels = "%Y"
  )) 

ggsave(filename = "tracking_history_cropped.png", 
       plot = tracking_history_subset,           
       width = 10, height = 6, units = "in",
       dpi = 300, 
       bg = "white")


# Combine
library(patchwork)
(combined_plot <- tracking_history / tracking_history_subset)

ggsave(filename = "tracking_history_combined.png", 
       plot = combined_plot,           
       width = 10, height = 6, units = "in",
       dpi = 300, 
       bg = "white")


## Survival Analysis ----------------------------------------------------------

## Multivariate ---------------------------------------------------------------

## Cox Proportional Hazard Model with staggered entry 
treatment <- "sex"
cox_fit <- coxph(Surv(entry_time_days, exit_time_days, mortality_event) ~ treatment, data = summary_table)
summary(cox_fit)

Work in soft-coding inputs and generating outputs 
